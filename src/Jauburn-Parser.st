PackageManifest subclass: #ManifestJauburnParser	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-Parser-Manifest'!!ManifestJauburnParser commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestJauburnParser class	instanceVariableNames: ''!!ManifestJauburnParser class methodsFor: 'code-critics'!ruleRBStringConcatenationRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#JbParser)) #'2019-07-26T14:49:32.296069-04:00') )! !!ManifestJauburnParser class methodsFor: 'code-critics'!ruleGRIvarNeitherReadNorWrittenRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#JbParser)) #'2019-07-26T13:18:08.679171-04:00') )! !PPCompositeParser subclass: #JbArithmeticExpressionParser	instanceVariableNames: 'arithmeticExpression numberExpression identifierExpression identifier arithmeticTerm arithmeticFactor'	classVariableNames: ''	package: 'Jauburn-Parser-Core'!!JbArithmeticExpressionParser commentStamp: '' prior: 0!I parse arithmetic expressions!!JbArithmeticExpressionParser methodsFor: 'accessing'!start 	^arithmeticExpression ! !!JbArithmeticExpressionParser methodsFor: 'non-terminals' stamp: 'NikkiU 11/28/2023 07:40'!arithmeticTerm	^ ((arithmeticFactor separatedBy:		    ('*' asParser / '/' asParser / '%' asParser) trim) foldLeft: [ 		   :a 		   :op 		   :b | 		   op = '*'			   ifTrue: [ 				   JbMultiplicationNode new					   lhs: a;					   rhs: b;					   yourself ]			   ifFalse: [ 				   op = '/'					   ifTrue: [ 						   JbDivisionNode new							   lhs: a;							   rhs: b;							   yourself ]					   ifFalse: [ 						   JbModuloNode new							   lhs: a;							   rhs: b;							   yourself ] ] ]) / arithmeticFactor! !!JbArithmeticExpressionParser methodsFor: 'non-terminals'!arithmeticFactor	^ '(' asParser trim , arithmeticExpression , ')' asParser trim	  ==> [ :arr | arr second ] / numberExpression	   / identifierExpression! !!JbArithmeticExpressionParser methodsFor: 'non-terminals' stamp: 'NikkiU 11/18/2023 16:32'!numberExpression	^ (self dependencyAt: JbNumberParser) number ==> [ :n | 	  JbConstantExpressionNode new		  value: n;		  yourself ]! !!JbArithmeticExpressionParser methodsFor: 'non-terminals'!identifierExpression	^ identifier ==> [ :arr | 	  JbIdentifierExpressionNode new		  identifier: arr;		  yourself ]! !!JbArithmeticExpressionParser methodsFor: 'non-terminals'!identifier	^ (#letter asParser	   , (#letter asParser / #digit asParser / $_ asParser) star) flatten		  trim! !!JbArithmeticExpressionParser methodsFor: 'non-terminals' stamp: 'NikkiU 11/23/2023 14:09'!arithmeticExpression	^ ((arithmeticTerm separatedBy: ('+' asParser / '-' asParser) trim) 		   foldLeft: [ :a :op :b | 			   op = '+'				   ifTrue: [ 					   JbAdditionNode new						   lhs: a;						   rhs: b;						   yourself ]				   ifFalse: [ 					   JbSubtractionNode new						   lhs: a;						   rhs: b;						   yourself ] ]) / arithmeticTerm! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JbArithmeticExpressionParser class	instanceVariableNames: ''!!JbArithmeticExpressionParser class methodsFor: 'accessing'!dependencies	^ { JbNumberParser }! !PPCompositeParser subclass: #JbNumberParser	instanceVariableNames: 'digitNotZero digit number'	classVariableNames: ''	package: 'Jauburn-Parser-Core'!!JbNumberParser commentStamp: 'NikkiU 11/18/2023 21:04' prior: 0!I handle the parsing of numbers is Jauburn.  I'm basically the CPIntegerParser introduced in the class videos.Updated to support integers and floats. Integer method was changed to Number method.instance variables:	digit	digitNotZero	number!!JbNumberParser methodsFor: 'non-terminals' stamp: 'NikkiU 11/19/2023 12:02'!number	"Parses a float or an integer"	^ ($- asParser optional , digitNotZero , digit star / $0 asParser	   , ($. asParser , digit star) optional	   / ($- asParser , $0 asParser , $. asParser , digit star)	   / ($0 asParser , $. asParser , digit star)) flatten	  ==> [ :str | str asNumber ]! !!JbNumberParser methodsFor: 'non-terminals'!digit	^$0 asParser / digitNotZero! !!JbNumberParser methodsFor: 'non-terminals'!digitNotZero	^$1 asParser / $2 asParser / $3 asParser 								/ $4 asParser / $5 asParser / $6 asParser								/ $7 asParser / $8 asParser / $9 asParser! !!JbNumberParser methodsFor: 'accessing' stamp: 'NikkiU 11/18/2023 16:32'!start	"Answer the production to start this parser with."	^ number! !PPCompositeParser subclass: #JbParser	instanceVariableNames: 'identifier expression assignmentStatement anonymousFunctionExpression returnStatement identifierExpression comparisonExpression arithmeticExpression expressionList functionCallExpression identifierExpressionList statementBlock statement variableDeclarationStatement program stringExpression stringComparisonExpression booleanExpression functionCallStatement printStatement ifStatement ifElseStatement whileStatement inputStatement'	classVariableNames: ''	package: 'Jauburn-Parser-Core'!!JbParser commentStamp: '' prior: 0!I am a parser for the Jauburn language.EBNF<program> ::=   <statement>*<statement> ::=   <variable-declaration-statement>   | <assignment-statement>   | <if-else-statement>   | <if-statement><variable-declaration-statement> ::=   var <identifier> = <expression> ;<assignment-statement> ::=   <identifier> = <expression> ;<if-statement> ::=   if '(' <expression> ')' <statement-block><if-else-statement> ::=   if '(' <expression> ')' <statement-block> else <statement-block>/* Cannot be in <keyword> */<identifier> ::=   <letter> <letter-or-digit-or-underscore>*<keyword> ::=   if   | var   | function<expression> ::=   <function-definition-expression>   | <function-call-expression>   | <arithmetic-expression>   | <comparison-expression><function-definition-expression> ::=   function '(' <identifier-list> ')' <statement-block><statement-block> ::=   '{' <statement>* '}'<identifier-list> ::=   <identifier>   | <identifier> , <identifier-list>   | epsilon    /* the empty expression */<function-call-expression> ::=   <identifier> '(' <expression-list> ')'<expression-list> ::=   <expression>   | <expression> , <expression-list>   | epsilon/* * A very simple grammar for comparison expressions. */<comparison-expression> ::=   <arithmetic-expression> == <arithmetic-expression>   | <arithmetic-expression> < <arithmetic-expression>   | <arithmetic-expression> <= <arithmetic-expression>   | <arithmetic-expression> > <arithmetic-expression>   | <arithmetic-expression> >= <arithmetic-expression>   | <arithmetic-expression> !!= <arithmetic-expression>/* * Expression grammar.  Note: this grammar isn't used directly by this paser. * Instead we are using a PPExpressionParser which takes care of precedence etc. * However, this grammar is correct for BNF purposes. */<arithmetic-expression> ::=   <arithmetic-expression> '+' <term>   | <arithmetic-expression> '-' <term>   | <term><term> ::=   <term> '*' <factor>   | <term> '/' <factor>   | <factor><factor> ::=   '(' <arithmetic-expression> ')'   | <number>   | <idenfitier>/* integer grammar from slides */digit_not_zero> ::=   1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9<digit> ::=    0    | <digit_not_zero><integer> ::=   '-'? <digit_not_zero><digit>*    | 0/* we can use #word asParser here */<letter> ::=   /  a character in set a-z or set 	A-Z   /<letter-or-digit-or-underscore> ::=   <digit>   | <letter>   | '_'!!JbParser methodsFor: 'accessing'!start 	^program! !!JbParser methodsFor: 'low-level'!keyword 	^'if' asParser	/ 'else' asParser	/ 'function' asParser! !!JbParser methodsFor: 'statements'!program	^ statement trim star		==> [ :stmts | 			JbProgramNode new				statements: stmts;				yourself ]! !!JbParser methodsFor: 'statements' stamp: 'NikkiU 11/23/2023 22:37'!ifStatement	^ self keyword trim , '(' asParser trim , self expression	  , ')' asParser trim , self statementBlock ==> [ :arr | 	  JbIfStatementNode new		  condition: arr third;		  thenStatements: arr fifth yourself ]! !!JbParser methodsFor: 'statements'!assignmentStatement	^ (identifier trim , $= asParser trim , expression , $; asParser)		==> [ :arr | 			JbAssignmentStatementNode new				identifier: arr first;				expression: arr third;				yourself ]! !!JbParser methodsFor: 'statements'!statementBlock 	^${ asParser trim,	statement trim star 	, $} asParser trim	  ==> [ :arr | arr second ]! !!JbParser methodsFor: 'statements' stamp: 'NikkiU 11/24/2023 14:39'!statement	^ variableDeclarationStatement / assignmentStatement	  / returnStatement / functionCallStatement / printStatement	  / ifElseStatement / ifStatement / whileStatement / inputStatement! !!JbParser methodsFor: 'statements' stamp: 'NikkiU 11/24/2023 13:59'!whileStatement	^ 'while' asParser trim , '(' asParser trim , self expression	  , ')' asParser trim , self statementBlock ==> [ :arr | 	  JbWhileStatementNode new		  condition: arr third;		  doStatements: arr fifth yourself ]! !!JbParser methodsFor: 'statements'!variableDeclarationStatement	^ ('var' asParser , #space asParser) trim , identifier	  , $= asParser trim , expression , $; asParser trim ==> [ :arr | 	  JbVariableDeclarationStatementNode new		  identifier: arr second;		  expression: arr fourth;		  yourself ]! !!JbParser methodsFor: 'statements'!functionCallStatement	^ (identifier , $( asParser trim , expressionList , $) asParser trim) , $; asParser trim		==> [ :arr | 			JbFunctionCallNode new				identifier: arr first;				arguments: arr third;				yourself ]! !!JbParser methodsFor: 'statements' stamp: 'NikkiU 11/24/2023 13:42'!ifElseStatement	^ self keyword trim , '(' asParser trim , self expression	  , ')' asParser trim , self statementBlock , self keyword trim	  , self statementBlock ==> [ :arr | 	  JbIfElseStatementNode new		  condition: arr third;		  thenStatements: arr fifth;		  elseStatements: arr seventh yourself ]! !!JbParser methodsFor: 'statements' stamp: 'NikkiU 11/24/2023 14:39'!inputStatement	^ ('inputnum' asParser , #space asParser) trim , identifier  	, ';' asParser trim	==> [ :arr | JbInputStatementNode new 		identifier: arr second ]! !!JbParser methodsFor: 'statements'!printStatement	^ ('print' asParser , #space asParser) trim , arithmeticExpression	  , ';' asParser trim	  ==> [ :arr | JbPrintStatementNode new expression: arr second ]! !!JbParser methodsFor: 'statements'!returnStatement	^'return' asParser trim , expression, $; asParser trim ==> [ :arr |			JbReturnStatementNode new				expression: arr second;				yourself ]! !!JbParser methodsFor: 'expressions'!functionCallExpression	^ (identifier , $( asParser trim , expressionList , $) asParser trim)		==> [ :arr | 			JbFunctionCallNode new				identifier: arr first;				arguments: arr third;				yourself ]! !!JbParser methodsFor: 'expressions'!identifierExpressionList	^ (identifierExpression , $, asParser not)		/ (identifierExpression , $, asParser trim , identifierExpressionList)		/ nil asParser		==> [ :arrOrNil | 			arrOrNil				ifNil: [ #() ]				ifNotNil: [ | result |					result := OrderedCollection new.					result add: arrOrNil first.					arrOrNil size = 3						ifTrue: [ result addAll: arrOrNil third ].					result ] ]! !!JbParser methodsFor: 'expressions'!expressionList	^ (expression , $, asParser not)		/ (expression , $, asParser trim , expressionList) / nil asParser		==> [ :arr | 			| result |			result := OrderedCollection new.			arr				ifNotNil: [ result add: arr first.					arr size = 3						ifTrue: [ result addAll: arr third ] ].			result ]! !!JbParser methodsFor: 'expressions'!stringComparisonExpression	^ stringExpression , '==' asParser trim , stringExpression	  / (stringExpression , '!!=' asParser trim , stringExpression)	  ==> [ :arr | 		  JbNumericComparisonNode new			  lhs: arr first;			  operator: arr second;			  rhs: arr third;			  yourself ]! !!JbParser methodsFor: 'expressions'!identifier	^ (self dependencyAt: JbArithmeticExpressionParser)		  identifier! !!JbParser methodsFor: 'expressions'!arithmeticExpression	^(self dependencyAt: JbArithmeticExpressionParser) arithmeticExpression! !!JbParser methodsFor: 'expressions'!expression 	^anonymousFunctionExpression 	/ comparisonExpression	/ stringComparisonExpression	/ stringExpression	/ booleanExpression	/ functionCallExpression 	/ arithmeticExpression ! !!JbParser methodsFor: 'expressions'!booleanExpression	^'true' asParser / 'false' asParser ==> [ :str | JbConstantExpressionNode new value: str = 'true'; yourself ]! !!JbParser methodsFor: 'expressions'!identifierExpression	^  (self dependencyAt: JbArithmeticExpressionParser)		  identifierExpression! !!JbParser methodsFor: 'expressions'!anonymousFunctionExpression	^ ('function' asParser , $( asParser trim , identifierExpressionList		, $) asParser trim , statementBlock)		==> [ :t | 			JbFunctionDefinitionNode new				parameters: t third;				body: t fifth;				yourself ]! !!JbParser methodsFor: 'expressions'!stringExpression	^ ($" asParser , $" asParser negate star , $" asParser) flatten trim 		==> [ :str | 			JbConstantExpressionNode new				value: str allButFirst allButLast;				yourself ]! !!JbParser methodsFor: 'expressions'!comparisonExpression	^ arithmeticExpression , '==' asParser trim , arithmeticExpression	  / (arithmeticExpression , '<' asParser trim , arithmeticExpression)	  /	  (arithmeticExpression , '<=' asParser trim , arithmeticExpression)	  / (arithmeticExpression , '>' asParser trim , arithmeticExpression)	  /	  (arithmeticExpression , '>=' asParser trim , arithmeticExpression)	  /	  (arithmeticExpression , '!!=' asParser trim , arithmeticExpression)	  ==> [ :arr | 		  JbNumericComparisonNode new			  lhs: arr first;			  operator: arr second;			  rhs: arr third;			  yourself ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JbParser class	instanceVariableNames: ''!!JbParser class methodsFor: 'accessing'!dependencies	^ { 			  JbArithmeticExpressionParser }! !