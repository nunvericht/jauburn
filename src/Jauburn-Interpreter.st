PackageManifest subclass: #ManifestJauburnInterpreter	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-Interpreter-Manifest'!!ManifestJauburnInterpreter commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!Object subclass: #JbEnvironment	instanceVariableNames: 'bindings outerEnvironment jbUIManager jbTranscript'	classVariableNames: ''	package: 'Jauburn-Interpreter-Core'!!JbEnvironment commentStamp: '' prior: 0!This is a copy of the Phsyche PEnvironment class!!JbEnvironment methodsFor: 'accessing'!outerEnvironment: anEnvironment	outerEnvironment := anEnvironment! !!JbEnvironment methodsFor: 'accessing' stamp: 'NikkiU 11/25/2023 18:41'!jbUIManager: aUIManager	jbUIManager := aUIManager! !!JbEnvironment methodsFor: 'accessing' stamp: 'NikkiU 12/1/2023 13:31'!jbTranscript	^ jbTranscript ifNil: [ Transcript ]! !!JbEnvironment methodsFor: 'accessing' stamp: 'NikkiU 11/25/2023 18:49'!jbUIManager	^ jbUIManager ifNil: [ UIManager default ]! !!JbEnvironment methodsFor: 'accessing'!variableNames	^ bindings keys! !!JbEnvironment methodsFor: 'accessing' stamp: 'NikkiU 12/1/2023 13:31'!jbTranscript: aTranscript	jbTranscript := aTranscript! !!JbEnvironment methodsFor: 'accessing'!lookupAt: aKey put: aValue	"Change the value of the binding whose key is aKey, but looking in the complete ancestor chain.	If the binding does not exist, it raises an error to indicate that we should define it first."	| found |	found := bindings at: aKey ifAbsent: nil.	found		ifNil: [ 			outerEnvironment				ifNotNil: [ outerEnvironment lookupAt: aKey put: aValue ]				ifNil: [ 				KeyNotFound signal: aKey , ' not found in the environment' ] ]		ifNotNil: [ self at: aKey put: aValue ]! !!JbEnvironment methodsFor: 'accessing'!at: aKey	| value |	value := bindings at: aKey ifAbsent: [ nil ].	^ value		  ifNil: [ 			  outerEnvironment				  ifNil: [ bindings at: aKey ]				  ifNotNil: [ outerEnvironment at: aKey ] ]		  ifNotNil: [ :v | v ]! !!JbEnvironment methodsFor: 'accessing'!at: aKey put: aValue	bindings at: aKey put: aValue! !!JbEnvironment methodsFor: 'accessing'!includesKey: aKey	^bindings includesKey: aKey! !!JbEnvironment methodsFor: 'accessing'!initialize 	super initialize .	bindings := Dictionary new.! !Object subclass: #JbFunction	instanceVariableNames: 'body parameters environment'	classVariableNames: ''	package: 'Jauburn-Interpreter-Core'!!JbFunction commentStamp: '' prior: 0!I am the value that results from evaluating a function.  My i-vars	parameters -- collection holding names of my parameters 	environment -- a JbEnvironment instance holding the environment in effect when I was created (closures!!)	body -- an AST node for the body of this function!!JbFunction methodsFor: 'accessing'!body: anObject	body := anObject! !!JbFunction methodsFor: 'accessing'!environment	^ environment! !!JbFunction methodsFor: 'accessing'!parameters	^ parameters! !!JbFunction methodsFor: 'accessing'!body	^ body! !!JbFunction methodsFor: 'accessing'!parameters: anObject	parameters := anObject! !!JbFunction methodsFor: 'accessing'!environment: anObject	environment := anObject! !!JbFunction methodsFor: 'api' stamp: 'NikkiU 11/28/2023 14:20'!call: arguments in: callEnvironment	"You need to implement this method!!  arguments will contain the arguments to pass to this function and callEnvironment will 	contain the environment in place when this function was created"	| args |	args := arguments collect: [ :arg | 		        JbConstantExpressionNode new value: arg ].	parameters		with: args		do: [ :param :arg | 		callEnvironment at: param identifier put: arg value ].	[ ^ body do: [ :each | each executeIn: callEnvironment ] ]		on: JbReturnException		do: [ :ex | ^ ex returnValue ]! !Object subclass: #JbInterpreter	instanceVariableNames: 'environment jbUIManager'	classVariableNames: ''	package: 'Jauburn-Interpreter-Core'!!JbInterpreter commentStamp: '' prior: 0!I am an interpreter for programs written in the Jauburn language.  My principle API methods are:	interpret: anAST -- given an abstract syntax tree, interpret it	run: aString -- parse and interpret the supplied string!!JbInterpreter methodsFor: 'initialization' stamp: 'NikkiU 11/25/2023 17:04'!initialize	super initialize.	environment := JbEnvironment new! !!JbInterpreter methodsFor: 'api' stamp: 'NikkiU 11/25/2023 16:28'!jbUIManager	^ jbUIManager ifNil: [ UIManager default ]! !!JbInterpreter methodsFor: 'api'!interpret: programString	| ast |	ast := self parse: programString.	self interpretAst: ast! !!JbInterpreter methodsFor: 'api'!interpretAst: ast	^ ast executeIn: environment! !!JbInterpreter methodsFor: 'api'!run: programString	"Just an alias for #interpret:"	self interpret: programString! !!JbInterpreter methodsFor: 'api'!parse: programString	| parser |	parser := JbParser new.	^(parser parse: programString)! !!JbInterpreter methodsFor: 'api' stamp: 'NikkiU 11/25/2023 15:17'!jbUIManager: aUIManager	jbUIManager := aUIManager! !!JbInterpreter methodsFor: 'accessing'!environment 	^environment! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JbInterpreter class	instanceVariableNames: ''!!JbInterpreter class methodsFor: 'functions' stamp: 'NikkiU 11/27/2023 23:40'!newWithStandardLibrary	^ self new interpret: self standardLibrary! !!JbInterpreter class methodsFor: 'functions' stamp: 'NikkiU 11/29/2023 07:27'!standardLibrary	"Defines function utilized in newWithStandardLibrary:	not(b), and(a,b), or(a,b), abs(f), sqrt(x), gcd(a,b) 		Newtons sqrt: 0.5 * (y + x/y) with y being a guess.		Euclid's gcd: If a = 0, then gcd a,b) = b 		If b= 0; then gcd(a,b) = a;  Else write a in quotient remainder form (a = b * q + r)		Find gcd(b,r) since gcd(a,b) = gcd(b,r)."	^ 'var not = function (b) { if (b) { return false; } 			else { return true; } };			var and = function (a,b) {if (a) 						{ if (b) { return true; }							 else { return false; } }								else { return false; } };										var or = function (a,b) { if (a) { return true; } 					else { if (b) { return true; } 						else { return false; } } };							var abs = function (x) { if (x >= 0) { return x;} 					else {return x * -1;} };			var sqrt = function (x) { if (x == 0) { return 0; } 							else { var y = 1; var z = 100;        						while (z > 1) {            						y = 0.5 * (y + x / y); z = z - 1; }        								return y; } };										var gcd = function (a, b) {if (b == 0) { return a; } 			else { return gcd(abs(b), abs(a % b)) ; } };'! !Error subclass: #JbReturnException	instanceVariableNames: 'returnValue'	classVariableNames: ''	package: 'Jauburn-Interpreter-Core'!!JbReturnException commentStamp: 'NikkiU 11/25/2023 22:32' prior: 0!Custom Exception Class for function return statements    Instance Variables	returnValue:		<Object>    Implementation Points!!JbReturnException methodsFor: 'accessing' stamp: 'NikkiU 11/25/2023 20:59'!returnValue: anObject	returnValue := anObject! !!JbReturnException methodsFor: 'accessing' stamp: 'NikkiU 11/25/2023 20:59'!returnValue	^ returnValue! !Object subclass: #JbSamplePrograms	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-Interpreter-SamplePrograms'!!JbSamplePrograms commentStamp: 'NikkiU 11/28/2023 06:53' prior: 0!Just a place to house a few sample programs gcdInputNum computes the gcd of a number sqrtInputNUm computes the sqrt of a number!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JbSamplePrograms class	instanceVariableNames: ''!!JbSamplePrograms class methodsFor: 'sample programs' stamp: 'NikkiU 12/1/2023 13:45'!gcdInputNum	"Computes the gcd of two numbers based on Euclid's algorithm "	"self run: self gcdInputNum"	Transcript		show:			'Please enter 2 numbers in the input boxes and this program will calculate the gcd(a,b)';		cr.	^ '	inputnum x; 		inputnum y;		var result = gcd(x,y);		print result;'! !!JbSamplePrograms class methodsFor: 'sample programs' stamp: 'NikkiU 11/25/2023 22:26'!noFunctions	"self run: self noFunctions"	^ 'var x = 4;var y = 10 * x + 2;print y;'! !!JbSamplePrograms class methodsFor: 'sample programs' stamp: 'NikkiU 11/28/2023 11:53'!testProgram	"self run: self testProgram"	^ 'var x = and ( 3 > 1, 1 < 2 );		print x;'! !!JbSamplePrograms class methodsFor: 'sample programs'!assignAndPrint	"self run: self assignAndPrint"	^ 'var x = 19;var y = 32 * ( x + 5 ) * x;print x;print y;print 5*y;'! !!JbSamplePrograms class methodsFor: 'sample programs' stamp: 'NikkiU 12/1/2023 13:44'!sqrtInputNum	"Computes the sqrt of a number using Newtons sqrt = 0.5 * (y + x/y) with y being a guess"	"self run: self sqrtInputNum"	Transcript		show:			'Please enter a number > 0 and this program will calculate the sqrt!!';		cr.	^ '	inputnum num; 		var result = sqrt(num);		print result;'! !!JbSamplePrograms class methodsFor: 'utilities' stamp: 'NikkiU 11/27/2023 21:07'!run: aString	"Look at sample programs for examples of using this method."	^ JbInterpreter newWithStandardLibrary run: aString! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.321 pm'!!JbReturnStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 22:07'!executeIn: environment	"When a return statement is executed, its operand should be evaluated (it is an expression) and returned to whoever	called the function without evaluating any additional statements in the function using a custom exception handler"	| returnValue returnExc |	returnValue := expression evaluateIn: environment.	returnExc := JbReturnException new returnValue: returnValue.	returnExc signal! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.321 pm'!!JbIdentifierExpressionNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: environment 	^environment at: self identifier! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.322 pm'!!JbNumericComparisonNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: environment	| lhsValue rhsValue |	lhsValue := self lhs evaluateIn: environment.	rhsValue := self rhs evaluateIn: environment.	self operator = '<' ifTrue: [ ^ lhsValue < rhsValue ].	self operator = '>' ifTrue: [ ^ lhsValue > rhsValue ].	self operator = '<=' ifTrue: [ ^ lhsValue <= rhsValue ].	self operator = '>=' ifTrue: [ ^ lhsValue >= rhsValue ].	self operator = '==' ifTrue: [ ^ lhsValue = rhsValue ].	self operator = '!!=' ifTrue: [ ^ lhsValue ~= rhsValue ].	self error: 'Unrecognized operator: ' , self operator asString! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.322 pm'!!JbIfStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 20:57'!executeIn: environment	"If statement exuction in interpreter"	(self condition evaluateIn: environment) ifTrue: [ 		self thenStatements do: [ :each | each executeIn: environment ] ]! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.322 pm'!!JbConstantExpressionNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: environment	^self value! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.322 pm'!!JbProgramNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 18:04'!executeIn: environment	statements do: [ :each | each executeIn: environment ]! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.323 pm'!!JbInputStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 20:57'!executeIn: environment	"Opens an input dialog when an inputnum statement executes in interpreter"	| input |	input := environment jbUIManager textEntry: 'Enter a number'.	environment at: self identifier put: input asNumber! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.323 pm'!!JbAssignmentStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 18:01'!executeIn: environment	environment		lookupAt: self identifier		put: (self expression evaluateIn: environment)! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.323 pm'!!JbIfElseStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 20:57'!executeIn: environment	"If-else statement exuction in interpreter"	(self condition evaluateIn: environment)		ifTrue: [ 		self thenStatements do: [ :each | each executeIn: environment ] ]		ifFalse: [ 		self elseStatements do: [ :each | each executeIn: environment ] ]! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.324 pm'!!JbArity2OperatorNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 20:57'!evaluateIn: environment	| lhsValue rhsValue |	lhsValue := self lhs evaluateIn: environment.	rhsValue := self rhs evaluateIn: environment.	self operator = $* ifTrue: [ ^ lhsValue * rhsValue ].	self operator = $/ ifTrue: [ ^ lhsValue / rhsValue ].	self operator = $% ifTrue: [ ^ lhsValue % rhsValue ].	self operator = $+ ifTrue: [ ^ lhsValue + rhsValue ].	self operator = $- ifTrue: [ ^ lhsValue - rhsValue ].		self error: 'Unrecognized operator: ' , self operator asString! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.324 pm'!!JbFunctionCallNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/28/2023 14:22'!executeIn: environment	"When a function call is evaluated, (like f(5)), create an environment (JbEnvironment) with the parameters boundto the values passed as arguments and evaluate the body in that environment. Note that function calls can be statements (doIt(10);) or expressions (var y = 2*f(3);) "	| argValues function newEnv |	function := environment at: identifier. "look up function identifier"	newEnv := JbEnvironment new. "Create a new JbEnvironment"	newEnv outerEnvironment: function environment.	argValues := arguments collect: [ :arg | arg evaluateIn: environment ].	^ function call: argValues in: newEnv! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.324 pm'!!JbFunctionCallNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/28/2023 14:21'!evaluateIn: environment	"When a function call is evaluated, (like f(5)), create an environment (JbEnvironment) with the parameters boundto the values passed as arguments and evaluate the body in that environment. Note that function calls can be statements (doIt(10);) or expressions (var y = 2*f(3);) "	| argValues function newEnv |	function := environment at: identifier. "look up function identifier"	newEnv := JbEnvironment new. "Create a new JbEnvironment"	newEnv outerEnvironment: function environment.	argValues := arguments collect: [ :arg | arg evaluateIn: environment ].	^ function call: argValues in: newEnv! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.325 pm'!!JbAbstractSyntaxTreeNode methodsFor: '*Jauburn-Interpreter'!executeIn: aContext	self error: 'Statements must override this method.  Expressions _must not_ override this method since it is an error to send #executeIn: to an expression.'! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.325 pm'!!JbAbstractSyntaxTreeNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: aContext	self error:		'Expressions must override this method.  Statements _must not_ override this method since it is an error to send #evaluateIn: to a statement.'! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.325 pm'!!JbPrintStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 12/1/2023 13:33'!executeIn: anEnvironment	| value |	value := expression evaluateIn: anEnvironment.		anEnvironment jbTranscript		show: value;		cr! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.325 pm'!!JbWhileStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 20:57'!executeIn: environment	"While statement exuction in interpreter"	[ self condition evaluateIn: environment ] whileTrue: [ 		self doStatements do: [ :each | each executeIn: environment ] ]! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.326 pm'!!JbFunctionDefinitionNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/26/2023 15:49'!evaluateIn: environment	"When a function definition is evaluated in the interpreter, create an instance of JbFunction"	^ JbFunction new		  parameters: self parameters;		  body: self body;		  environment: environment;		  yourself! !'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 1 December 2023 at 2:20:45.326 pm'!!JbVariableDeclarationStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 18:01'!executeIn: environment	environment		at: self identifier		put: (self expression evaluateIn: environment)! !