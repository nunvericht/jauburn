PackageManifest subclass: #ManifestJauburnAST	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-AST-Manifest'!!ManifestJauburnAST commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ManifestJauburnAST class	instanceVariableNames: ''!!ManifestJauburnAST class methodsFor: 'code-critics'!ruleRBNoClassCommentRuleV1FalsePositive	^ #(#(#(#RGPackage #(#'Jauburn-AST')) #'2019-07-26T16:07:56.982481-04:00') )! !Object subclass: #JbAbstractSyntaxTreeNode	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbAbstractSyntaxTreeNode commentStamp: '' prior: 0!I am an abstract class.  My descendents are abstract syntax tree nodes.  Except for the interpreter, I don't define any API methods since the nodes have no methods in common.!!JbAbstractSyntaxTreeNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: aContext	self error:		'Expressions must override this method.  Statements _must not_ override this method since it is an error to send #evaluateIn: to a statement.'! !!JbAbstractSyntaxTreeNode methodsFor: '*Jauburn-Interpreter'!executeIn: aContext	self error: 'Statements must override this method.  Expressions _must not_ override this method since it is an error to send #executeIn: to an expression.'! !JbAbstractSyntaxTreeNode subclass: #JbArity2OperatorNode	instanceVariableNames: 'lhs rhs'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbArity2OperatorNode commentStamp: 'NikkiU 11/28/2023 11:22' prior: 0!Abstract Syntax Tree Parent Class for Operator Nodes.Subclass of JbAbstractSyntaxTreeNode  Internal Representation and Key Implementation Points.	 Overrides:	evaluateIn:		 Overridden:	operator		 Instance Variables	lhs:		<Object>	rhs:		<Object>    Implementation Points!!JbArity2OperatorNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 20:57'!evaluateIn: environment	| lhsValue rhsValue |	lhsValue := self lhs evaluateIn: environment.	rhsValue := self rhs evaluateIn: environment.	self operator = $* ifTrue: [ ^ lhsValue * rhsValue ].	self operator = $/ ifTrue: [ ^ lhsValue / rhsValue ].	self operator = $% ifTrue: [ ^ lhsValue % rhsValue ].	self operator = $+ ifTrue: [ ^ lhsValue + rhsValue ].	self operator = $- ifTrue: [ ^ lhsValue - rhsValue ].		self error: 'Unrecognized operator: ' , self operator asString! !!JbArity2OperatorNode methodsFor: 'accessing'!lhs	^ lhs! !!JbArity2OperatorNode methodsFor: 'accessing'!rhs: anObject	rhs := anObject! !!JbArity2OperatorNode methodsFor: 'accessing'!rhs	^ rhs! !!JbArity2OperatorNode methodsFor: 'accessing'!lhs: anObject	lhs := anObject! !!JbArity2OperatorNode methodsFor: 'accessing'!operator	^ self subclassResponsibility ! !JbArity2OperatorNode subclass: #JbAdditionNode	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbAdditionNode commentStamp: 'NikkiU 11/28/2023 11:25' prior: 0!Subclass of JbArityOperatorNodeAbstract Syntax Tree Parent Class for Operator Nodes.Subclass of JbAbstractSyntaxTreeNode  Internal Representation and Key Implementation Points. Overrides:	operatorInherits    Instance Variables	lhs:		<Object>	rhs:		<Object>Operator Method returns subclass operator!!JbAdditionNode methodsFor: 'accessing'!operator	^ $+! !JbAbstractSyntaxTreeNode subclass: #JbConstantExpressionNode	instanceVariableNames: 'value'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbConstantExpressionNode commentStamp: 'NikkiU 11/28/2023 11:22' prior: 0!Abstract Syntax Tree class for Constant Expression NodesSubclass of JbAbstractSyntaxTreeNode  Internal Representation and Key Implementation Points.	 Overrides:	evaluateIn:	value    Instance Variables	value:		<Object>    Implementation Points!!JbConstantExpressionNode methodsFor: 'accessing'!value	^ value! !!JbConstantExpressionNode methodsFor: 'accessing'!value: anObject	value := anObject! !!JbConstantExpressionNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: environment	^self value! !JbArity2OperatorNode subclass: #JbDivisionNode	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbDivisionNode commentStamp: 'NikkiU 11/21/2023 18:28' prior: 0!Subclass of JbArityOperatorNode Inherits    Instance Variables	lhs:		<Object>	rhs:		<Object>Operator Method returns subclass operator!!JbDivisionNode methodsFor: 'accessing' stamp: 'NikkiU 11/18/2023 21:27'!operator	^ $/! !JbAbstractSyntaxTreeNode subclass: #JbFunctionCallNode	instanceVariableNames: 'identifier arguments'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbFunctionCallNode commentStamp: 'NikkiU 11/28/2023 11:22' prior: 0!Abstract Syntax Tree  for Function Calls-created when a function call is encounteredSubclass of JbAbstractSyntaxTreeNode Internal Representation and Key Implementation Points.	 Overrides:	evaluateIn:	executeIn:    Instance Variables	arguments:		<Object>	identifier:		<Object>    Implementation Points:	When a function call is evaluated, (like f(5)), create an environment (JbEnvironment) with the parameters bound	to the values passed as arguments and evaluate the body in that environment. 	Note that function calls can be statements (doIt(10);) or expressions (var y = 2*f(3);) so you will need to implement both evaluateIn:	and executeIn:.!!JbFunctionCallNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/28/2023 14:21'!evaluateIn: environment	"When a function call is evaluated, (like f(5)), create an environment (JbEnvironment) with the parameters boundto the values passed as arguments and evaluate the body in that environment. Note that function calls can be statements (doIt(10);) or expressions (var y = 2*f(3);) "	| argValues function newEnv |	function := environment at: identifier. "look up function identifier"	newEnv := JbEnvironment new. "Create a new JbEnvironment"	newEnv outerEnvironment: function environment.	argValues := arguments collect: [ :arg | arg evaluateIn: environment ].	^ function call: argValues in: newEnv! !!JbFunctionCallNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/28/2023 14:22'!executeIn: environment	"When a function call is evaluated, (like f(5)), create an environment (JbEnvironment) with the parameters boundto the values passed as arguments and evaluate the body in that environment. Note that function calls can be statements (doIt(10);) or expressions (var y = 2*f(3);) "	| argValues function newEnv |	function := environment at: identifier. "look up function identifier"	newEnv := JbEnvironment new. "Create a new JbEnvironment"	newEnv outerEnvironment: function environment.	argValues := arguments collect: [ :arg | arg evaluateIn: environment ].	^ function call: argValues in: newEnv! !!JbFunctionCallNode methodsFor: 'accessing'!arguments: anObject	arguments := anObject! !!JbFunctionCallNode methodsFor: 'accessing'!identifier: anObject	identifier := anObject! !!JbFunctionCallNode methodsFor: 'accessing'!identifier	^ identifier! !!JbFunctionCallNode methodsFor: 'accessing'!arguments	^ arguments! !JbAbstractSyntaxTreeNode subclass: #JbFunctionDefinitionNode	instanceVariableNames: 'body parameters'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbFunctionDefinitionNode commentStamp: 'NikkiU 11/28/2023 11:22' prior: 0!AST for Function Definitions-created when a function definition is encountered.<function-definition-expression> ::=   function '(' <identifier-list> ')' <statement-block>Internal Representation and Key Implementation Points.    Instance Variables	body:		<Object>	parameters:		<Object>    Implementation PointsWhen a function definition is evaluated, the interpreter should create an instance of JbFunction (this class isincluded), filling in its instance variables appropriately.  When a function (like function(x) { return 2 *x; }) is evaluated, we create a value (a JbFunction).!!JbFunctionDefinitionNode methodsFor: 'accessing'!body	^ body! !!JbFunctionDefinitionNode methodsFor: 'accessing'!parameters	^ parameters! !!JbFunctionDefinitionNode methodsFor: 'accessing'!parameters: anObject	parameters := anObject! !!JbFunctionDefinitionNode methodsFor: 'accessing'!body: anObject	body := anObject! !!JbFunctionDefinitionNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/26/2023 15:49'!evaluateIn: environment	"When a function definition is evaluated in the interpreter, create an instance of JbFunction"	^ JbFunction new		  parameters: self parameters;		  body: self body;		  environment: environment;		  yourself! !JbAbstractSyntaxTreeNode subclass: #JbIdentifierExpressionNode	instanceVariableNames: 'identifier'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbIdentifierExpressionNode commentStamp: 'NikkiU 11/28/2023 11:21' prior: 0!Abstract Syntax Tree class for Identifier Expression NodesSubclass of JbAbstractSyntaxTreeNode  Internal Representation and Key Implementation Points.	 Overrides:	evaluateIn:    Instance Variables	identifier:		<Object> Implementation Points!!JbIdentifierExpressionNode methodsFor: 'accessing'!identifier: anObject	identifier := anObject! !!JbIdentifierExpressionNode methodsFor: 'accessing'!identifier	^ identifier! !!JbIdentifierExpressionNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: environment 	^environment at: self identifier! !JbAbstractSyntaxTreeNode subclass: #JbIfStatementNode	instanceVariableNames: 'condition thenStatements'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbIfStatementNode commentStamp: 'NikkiU 11/28/2023 11:24' prior: 0!Abstract Syntax Tree Node Parent Class for If then statementSubclass of JbAbstractSyntaxTreeNode Subclass: JbIfElseStatementNode<if-statement> ::=if '(' <expression> ')' <statement-block>Internal Representation and Key Implementation Points.	 Overrides:	executeIn:		 Overridden:	executeIn:	 Instance Variables	condition:		<Object>	thenStatements:		<Object>						 Implementation Points!!JbIfStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 20:57'!executeIn: environment	"If statement exuction in interpreter"	(self condition evaluateIn: environment) ifTrue: [ 		self thenStatements do: [ :each | each executeIn: environment ] ]! !!JbIfStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/23/2023 22:30'!condition: anObject	condition := anObject! !!JbIfStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/23/2023 22:30'!thenStatements: anObject	thenStatements := anObject! !!JbIfStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/23/2023 22:29'!condition	^ condition! !!JbIfStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/23/2023 22:30'!thenStatements	^ thenStatements! !JbIfStatementNode subclass: #JbIfElseStatementNode	instanceVariableNames: 'elseStatements'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbIfElseStatementNode commentStamp: 'NikkiU 11/28/2023 11:24' prior: 0!Abstract Syntax Tree Node class for If-else statementSubclass of JbIfStatementNode<if-else-statement> ::=   if '(' <expression> ')' <statement-block> else <statement-block> Internal Representation and Key Implementation Points.	Overrides:	executeIn:	   Inherited Instance Variables	condition:		<Object>	thenStatements:		<Object>   Instance Variables	elseStatements:		<Object> Implementation Points!!JbIfElseStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/24/2023 11:29'!elseStatements	^ elseStatements! !!JbIfElseStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/24/2023 11:29'!elseStatements: anObject	elseStatements := anObject! !!JbIfElseStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 20:57'!executeIn: environment	"If-else statement exuction in interpreter"	(self condition evaluateIn: environment)		ifTrue: [ 		self thenStatements do: [ :each | each executeIn: environment ] ]		ifFalse: [ 		self elseStatements do: [ :each | each executeIn: environment ] ]! !JbAbstractSyntaxTreeNode subclass: #JbInputStatementNode	instanceVariableNames: 'identifier'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbInputStatementNode commentStamp: 'NikkiU 11/28/2023 11:15' prior: 0!Abstract Syntax Tree Node class for inputnum statementSubclass of JbAbstractSyntaxTreeNode 	Overrides:	executeIn:		Instance Variables	identifier:		<Object>   Implementation Points	When an inputnum statement executes, opens an input dialog with 	JbUIManager (UIManager default).  ui is overriden in tests.!!JbInputStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 20:57'!executeIn: environment	"Opens an input dialog when an inputnum statement executes in interpreter"	| input |	input := environment jbUIManager textEntry: 'Enter a number'.	environment at: self identifier put: input asNumber! !!JbInputStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/24/2023 14:27'!identifier: anObject	identifier:= anObject! !!JbInputStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/24/2023 14:27'!identifier	^ identifier! !JbArity2OperatorNode subclass: #JbModuloNode	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbModuloNode commentStamp: 'NikkiU 11/28/2023 07:39' prior: 0!Subclass of JbArityOperatorNode Inherits    Instance Variables	lhs:		<Object>	rhs:		<Object>Operator Method returns subclass operator!!JbModuloNode methodsFor: 'accessing' stamp: 'NikkiU 11/28/2023 07:39'!operator	^ $%! !JbArity2OperatorNode subclass: #JbMultiplicationNode	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbMultiplicationNode commentStamp: 'NikkiU 11/21/2023 18:28' prior: 0!Subclass of JbArityOperatorNode Inherits    Instance Variables	lhs:		<Object>	rhs:		<Object>Operator Method returns subclass operator!!JbMultiplicationNode methodsFor: 'accessing'!operator	^ $*! !JbArity2OperatorNode subclass: #JbNumericComparisonNode	instanceVariableNames: 'operator'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbNumericComparisonNode commentStamp: '' prior: 0!Numeric comparison.  Note: unlike numeric operations, comparisons are all instances of this class but with different values for the operator.  There are no separate subclasses for equality, less than or equal to and so on.  Honestly, this approach could have been used in arithmetic as well but I didn't want to change it post-lecture video.!!JbNumericComparisonNode methodsFor: '*Jauburn-Interpreter'!evaluateIn: environment	| lhsValue rhsValue |	lhsValue := self lhs evaluateIn: environment.	rhsValue := self rhs evaluateIn: environment.	self operator = '<' ifTrue: [ ^ lhsValue < rhsValue ].	self operator = '>' ifTrue: [ ^ lhsValue > rhsValue ].	self operator = '<=' ifTrue: [ ^ lhsValue <= rhsValue ].	self operator = '>=' ifTrue: [ ^ lhsValue >= rhsValue ].	self operator = '==' ifTrue: [ ^ lhsValue = rhsValue ].	self operator = '!!=' ifTrue: [ ^ lhsValue ~= rhsValue ].	self error: 'Unrecognized operator: ' , self operator asString! !!JbNumericComparisonNode methodsFor: 'accessing' stamp: 'NikkiU 11/21/2023 17:46'!operator: anObject	operator := anObject! !!JbNumericComparisonNode methodsFor: 'accessing'!operator	^ operator! !JbAbstractSyntaxTreeNode subclass: #JbPrintStatementNode	instanceVariableNames: 'expression'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbPrintStatementNode commentStamp: 'NikkiU 11/28/2023 14:58' prior: 0!Abstract Syntax Tree Node class for print statement Internal Representation and Key Implementation Points.	 Overrides:	executeIn:    Instance Variables	expression:		<Object>    Implementation Points!!JbPrintStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 12/1/2023 13:33'!executeIn: anEnvironment	| value |	value := expression evaluateIn: anEnvironment.		anEnvironment jbTranscript		show: value;		cr! !!JbPrintStatementNode methodsFor: 'accessing'!expression	^ expression! !!JbPrintStatementNode methodsFor: 'accessing'!expression: anObject	expression := anObject! !JbAbstractSyntaxTreeNode subclass: #JbProgramNode	instanceVariableNames: 'statements'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbProgramNode commentStamp: 'NikkiU 11/28/2023 14:59' prior: 0!Abstract Syntax Tree Node class for Program Node Internal Representation and Key Implementation Points.	 Overrides:	executeIn:    Instance Variables	statements:		<Object>    Implementation Points!!JbProgramNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 18:04'!executeIn: environment	statements do: [ :each | each executeIn: environment ]! !!JbProgramNode methodsFor: 'accessing'!statements: anObject	statements := anObject! !!JbProgramNode methodsFor: 'accessing'!statements	^ statements! !JbAbstractSyntaxTreeNode subclass: #JbReturnStatementNode	instanceVariableNames: 'expression'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbReturnStatementNode commentStamp: 'NikkiU 11/28/2023 15:00' prior: 0!Abstract Syntax Tree Return Statement Node-created when a return statement is encountered.Internal Representation and Key Implementation Points.	 Overrides:	executeIn:    Instance Variables	expression:		<Object>    Implementation Points:When a return statement is executed, its operand should be evaluated (it is an expression) and returned to whoevercalled the function without evaluating any additional statements in the function. Uses a custom exception.!!JbReturnStatementNode methodsFor: 'accessing'!expression	^ expression! !!JbReturnStatementNode methodsFor: 'accessing'!expression: anObject	expression := anObject! !!JbReturnStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 22:07'!executeIn: environment	"When a return statement is executed, its operand should be evaluated (it is an expression) and returned to whoever	called the function without evaluating any additional statements in the function using a custom exception handler"	| returnValue returnExc |	returnValue := expression evaluateIn: environment.	returnExc := JbReturnException new returnValue: returnValue.	returnExc signal! !JbArity2OperatorNode subclass: #JbSubtractionNode	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbSubtractionNode commentStamp: 'NikkiU 11/21/2023 18:28' prior: 0!Subclass of JbArityOperatorNode Inherits    Instance Variables	lhs:		<Object>	rhs:		<Object>Operator Method returns subclass operator!!JbSubtractionNode methodsFor: 'accessing' stamp: 'NikkiU 11/18/2023 21:28'!operator	^ $-! !JbAbstractSyntaxTreeNode subclass: #JbVariableDeclarationStatementNode	instanceVariableNames: 'identifier expression'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbVariableDeclarationStatementNode commentStamp: 'NikkiU 11/28/2023 15:01' prior: 0!Abstract Syntax Tree for Variable Declaration StatementsInternal Representation and Key Implementation Points.	 Overrides:	executeIn:     Instance Variables	expression:		<Object>	identifier:		<Object>    Implementation Points!!JbVariableDeclarationStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 18:01'!executeIn: environment	environment		at: self identifier		put: (self expression evaluateIn: environment)! !!JbVariableDeclarationStatementNode methodsFor: 'accessing'!identifier	^ identifier! !!JbVariableDeclarationStatementNode methodsFor: 'accessing'!identifier: anObject	identifier := anObject! !!JbVariableDeclarationStatementNode methodsFor: 'accessing'!expression	^ expression! !!JbVariableDeclarationStatementNode methodsFor: 'accessing'!expression: anObject	expression := anObject! !JbVariableDeclarationStatementNode subclass: #JbAssignmentStatementNode	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbAssignmentStatementNode commentStamp: 'NikkiU 11/28/2023 15:02' prior: 0!Abstract Syntax Tree for Assignment Statement NodesSubclass of Variable Declaration Statement NodeInternal Representation and Key Implementation Points.	 Overrides:	executeIn:	expression:		<Object>	identifier:		<Object>    Implementation Points!!JbAssignmentStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 18:01'!executeIn: environment	environment		lookupAt: self identifier		put: (self expression evaluateIn: environment)! !JbAbstractSyntaxTreeNode subclass: #JbWhileStatementNode	instanceVariableNames: 'condition doStatements'	classVariableNames: ''	package: 'Jauburn-AST-Core'!!JbWhileStatementNode commentStamp: 'NikkiU 11/25/2023 20:08' prior: 0!Abstract syntax tree node class for while statement Internal Representation and Key Implementation Points.    Instance Variables	condition:		<Object>	doStatements:		<Object>    Implementation Points!!JbWhileStatementNode methodsFor: '*Jauburn-Interpreter' stamp: 'NikkiU 11/25/2023 20:57'!executeIn: environment	"While statement exuction in interpreter"	[ self condition evaluateIn: environment ] whileTrue: [ 		self doStatements do: [ :each | each executeIn: environment ] ]! !!JbWhileStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/24/2023 13:55'!condition: anObject	condition:= anObject! !!JbWhileStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/24/2023 13:55'!doStatements	^ doStatements! !!JbWhileStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/24/2023 13:54'!condition	^ condition! !!JbWhileStatementNode methodsFor: 'accessing' stamp: 'NikkiU 11/24/2023 13:55'!doStatements: anObject	doStatements := anObject! !