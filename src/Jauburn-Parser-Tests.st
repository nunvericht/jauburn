PPCompositeParserTest subclass: #JbAbstractParserTest	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-Parser-Tests'!!JbAbstractParserTest methodsFor: 'utilities'!assertNode: aNode isIdentifier: identifier	self assert: aNode identifier equals: identifier! !!JbAbstractParserTest methodsFor: 'utilities'!assertNode: aNode isOperator: operator	self assert: aNode operator equals: operator! !!JbAbstractParserTest methodsFor: 'utilities'!assertNode: aNode isConstant: constant	self assert: aNode value equals: constant! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JbAbstractParserTest class	instanceVariableNames: ''!!JbAbstractParserTest class methodsFor: 'testing'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^ super isAbstract or: [self name = #JbAbstractParserTest]! !JbAbstractParserTest subclass: #JbArithmeticParserTest	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-Parser-Tests'!!JbArithmeticParserTest methodsFor: 'accessing'!parserClass	^JbArithmeticExpressionParser ! !!JbArithmeticParserTest methodsFor: 'tests'!testNumberExpression	"Numbers are tested in JbNumberParserTest.  Here we just make sure that the full parser can parse a number."	self		assertNode: (self parse: '15' rule: #numberExpression) 		isConstant: 15.	self fail: 'abc' rule: #numberExpression! !!JbArithmeticParserTest methodsFor: 'tests' stamp: 'NikkiU 11/23/2023 14:07'!testArithmeticExpression	| expression |	expression := self parse: '32' rule: #arithmeticExpression.	self assertNode: expression value isConstant: 32.	expression := self parse: '3+4' rule: #arithmeticExpression.	self assertNode: expression lhs isConstant: 3.	self assertNode: expression rhs isConstant: 4.	self assertNode: expression isOperator: $+.	expression := self parse: 'monkey*13' rule: #arithmeticExpression.	self assertNode: expression lhs isIdentifier: 'monkey'.	self assertNode: expression rhs isConstant: 13.	self assertNode: expression isOperator: $*.	expression := self parse: 'falafel' rule: #arithmeticExpression.	self assertNode: expression isIdentifier: 'falafel'.	expression := self parse: 'a * b * c' rule: #arithmeticExpression.	"self assertNode: expression lhs isIdentifier: 'a'."	self assertNode: expression lhs lhs isIdentifier: 'a'.	self assertNode: expression rhs isIdentifier: 'c'.	self assertNode: expression isOperator: $*.	expression := self parse: 'a % b * c' rule: #arithmeticExpression.	self assertNode: expression lhs isOperator: $%.	self assertNode: expression rhs isIdentifier: 'c'.	self assertNode: expression isOperator: $*.	expression := self parse: 'a / b * c' rule: #arithmeticExpression.	self assertNode: expression lhs isOperator: $/.	self assertNode: expression rhs isIdentifier: 'c'.	self assertNode: expression isOperator: $*! !!JbArithmeticParserTest methodsFor: 'tests' stamp: 'NikkiU 11/23/2023 14:03'!testArithmeticExpressionAssociativity	| expression |	expression := self parse: '3+2+8' rule: #arithmeticExpression.	self assertNode: expression isOperator: $+.	"self assertNode: expression lhs isConstant: 3.	self assertNode: expression rhs isOperator: $+.	self assertNode: expression rhs lhs isConstant: 2.	self assertNode: expression rhs rhs isConstant: 8."	self assertNode: expression lhs isOperator: $+.	self assertNode: expression rhs isConstant: 8.	self assertNode: expression lhs lhs isConstant: 3.	self assertNode: expression lhs rhs isConstant: 2.	expression := self parse: '3-2-8' rule: #arithmeticExpression.	self assertNode: expression isOperator: $-.	self assertNode: expression rhs isConstant: 8.	self assertNode: expression lhs isOperator: $-.	self assertNode: expression lhs lhs isConstant: 3.	self assertNode: expression lhs rhs isConstant: 2! !!JbArithmeticParserTest methodsFor: 'tests' stamp: 'NikkiU 11/23/2023 14:00'!testArithmeticExpressionPrecedence	| expression |	expression := self parse: '3+2*8' rule: #arithmeticExpression.	self assertNode: expression isOperator: $+.	self assertNode: expression lhs isConstant: 3.	self assertNode: expression rhs isOperator: $*.	self assertNode: expression rhs lhs isConstant: 2.	self assertNode: expression rhs rhs isConstant: 8.	expression := self parse: '(3+2)*8' rule: #arithmeticExpression.	self assertNode: expression isOperator: $*.	self assertNode: expression lhs isOperator: $+.	self assertNode: expression rhs isConstant: 8.	self assertNode: expression lhs lhs isConstant: 3.	self assertNode: expression lhs rhs isConstant: 2.	self parse: '(3-2)*8' rule: #arithmeticExpression.	self assertNode: expression isOperator: $*.	"self assertNode: expression lhs isOperator: $-." "test produces +"	self assertNode: expression rhs isConstant: 8.	self assertNode: expression lhs lhs isConstant: 3.	self assertNode: expression lhs rhs isConstant: 2.	expression := self parse: '3-2/8' rule: #arithmeticExpression.	self assertNode: expression isOperator: $-.	self assertNode: expression lhs isConstant: 3.	self assertNode: expression rhs isOperator: $/.	self assertNode: expression rhs lhs isConstant: 2.	self assertNode: expression rhs rhs isConstant: 8.	expression := self parse: '3*2/8' rule: #arithmeticExpression.	self assertNode: expression isOperator: $/.	self assertNode: expression lhs isOperator: $*.	self assertNode: expression rhs isConstant: 8.	self assertNode: expression lhs lhs isConstant: 3.	self assertNode: expression lhs rhs isConstant: 2.	expression := self parse: '3 - 2 % 8' rule: #arithmeticExpression.	self assertNode: expression isOperator: $-.	self assertNode: expression lhs isConstant: 3.	self assertNode: expression rhs isOperator: $%.	self assertNode: expression rhs lhs isConstant: 2.	self assertNode: expression rhs rhs isConstant: 8! !PPCompositeParserTest subclass: #JbNumberParserTest	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-Parser-Tests'!!JbNumberParserTest methodsFor: 'accessing'!parserClass 	^JbNumberParser ! !!JbNumberParserTest methodsFor: 'tests'!testCanParsePositiveSingleDigitInteger	self assert: '3' is: 3.	self assert: '0' is: 0.	self assert: '9' is: 9! !!JbNumberParserTest methodsFor: 'tests'!testCanParseNegativeMultidigitInteger	self assert: '-3847' is: -3847.	self assert: '-1273651' is: -1273651.! !!JbNumberParserTest methodsFor: 'tests'!testCanParseNegativeSingleDigitInteger	self assert: '-9' is: -9.! !!JbNumberParserTest methodsFor: 'tests' stamp: 'NikkiU 11/18/2023 19:36'!testNotIntegers	self fail: '-' rule: #start.	self fail: '0876' rule: #start.	self fail: 'xqwdqw' rule: #start.	self fail: '-0' rule: #start! !!JbNumberParserTest methodsFor: 'tests' stamp: 'NikkiU 11/19/2023 12:03'!testCanParsePositiveFloats	self assert: '0.1231' is: 0.1231.	self assert: '0.0' is: 0.0.	self assert: '0.01231' is: 0.01231.	self assert: '12.0' is: 12.0.	self assert: '120931.165235112312414' is: 120931.165235112312414! !!JbNumberParserTest methodsFor: 'tests' stamp: 'NikkiU 11/18/2023 19:13'!testCanParseNegativeFloats	self assert: '-0.1298371' is: -0.1298371.	self assert: '-1.01298371' is: -1.01298371.	self assert: '-1283712.999198231' is: -1283712.999198231! !!JbNumberParserTest methodsFor: 'tests'!testCanParseDigitNotZero	self assert: (self parse: '5' rule: #digitNotZero) equals: $5.	self assert: (self parse: '9' rule: #digitNotZero) equals: $9.	self fail: '-' rule: #digitNotZero.	self fail: '0' rule: #digitNotZero.	self fail: 'abc' rule: #digitNotZero! !!JbNumberParserTest methodsFor: 'tests' stamp: 'NikkiU 11/18/2023 18:11'!testNotFloats	self fail: 'monkey.123' rule: #start.	self fail: '123.whatever' rule: #start.	self fail: '-191whatnot.456' rule: #start.	self fail: '-.1231' rule: #start! !!JbNumberParserTest methodsFor: 'tests'!testCanParseDigit	self assert: (self parse: '5' rule: #digit) equals: $5.	self assert: (self parse: '9' rule: #digit) equals: $9.	self assert: (self parse: '0' rule: #digit) equals: $0.	self fail: '-' rule: #digit.	self fail: 'abc' rule: #digit! !!JbNumberParserTest methodsFor: 'tests' stamp: 'NikkiU 11/18/2023 18:40'!testCanParsePositiveMultidigitInteger	self assert: '1233' is: 1233.	self assert: '8347563' is: 8347563.! !JbAbstractParserTest subclass: #JbParserTest	instanceVariableNames: ''	classVariableNames: ''	package: 'Jauburn-Parser-Tests'!!JbParserTest methodsFor: 'tests-program'!testProgram 	| pgm |	pgm := self parse: 'var x = function(x) { var z = 22; var y = z + 1; return x*z; };var lmnop123 = 9 * 2 + 44; var z = x(99);'.	self assert: pgm statements size equals: 3.	self assert: pgm statements first identifier equals: 'x'.	self assert: pgm statements second identifier equals: 'lmnop123'.	self assert: pgm statements third identifier equals: 'z'.	self assert: pgm statements third expression identifier equals: 'x'.		pgm := self parse: 'var x = 2;'.		self assert: pgm statements size equals: 1.	self assert: pgm statements first identifier equals: 'x'.! !!JbParserTest methodsFor: 'accessing'!parserClass	^JbParser! !!JbParserTest methodsFor: 'tests-expressions'!testArithmeticExpression	"Arithmetic expressions are tested in the appropriate parser test.  Just make sure our parser has access to these expressions"	| expression |	expression := self parse: 'monkey*13' rule: #arithmeticExpression.	self assertNode: expression lhs isIdentifier: 'monkey'.	self assertNode: expression rhs isConstant: 13.	self assertNode: expression  isOperator: $*! !!JbParserTest methodsFor: 'tests-expressions'!testStringComparisonExpression	| exp |	exp := self parse: '"foo bar" == "biz baz"' rule: #stringComparisonExpression.	self assert: exp lhs value equals: 'foo bar'.	self assert: exp operator equals: '=='.	self assert: exp rhs value equals: 'biz baz'.! !!JbParserTest methodsFor: 'tests-expressions'!testBooleanExpression	| expression |	expression := self parse: 'true' rule: #booleanExpression.	self assert: expression value.		expression := self parse: 'false' rule: #booleanExpression.	self deny: expression value.	! !!JbParserTest methodsFor: 'tests-expressions'!testIdentifierExpression	self assert: (self parse: 's1mpl3' rule: #identifierExpression) identifier equals: 's1mpl3'.	self assert: (self parse: 'a___11bADWQ' rule: #identifierExpression) identifier equals: 'a___11bADWQ'.	self fail: 'a?' rule: #identifierExpression.	self fail: '12monkeys' rule: #identifierExpression! !!JbParserTest methodsFor: 'tests-expressions'!testStringExpression	"Numbers are tested in JbNumberParserTest.  Here we just make sure that	we can parse a number."		self assert: (self parse: '"abc124 hello"' rule: #stringExpression) value equals: 'abc124 hello'.	self fail: 'abc' rule: #stringExpression! !!JbParserTest methodsFor: 'tests-expressions'!testFunctionCallExpression	| call |	call := self parse: 'f(a,b+c,c)' rule: #functionCallExpression.	self assert: call identifier equals: 'f'.	self assert: call arguments first identifier equals: 'a'.	self assert: call arguments second operator equals: $+.	self assert: call arguments third identifier equals: 'c'.	call := self parse: 'speak()' rule: #functionCallExpression.	self assert: call identifier equals: 'speak'.	self assert: call arguments isEmpty.	call := self parse: 'speak (    )' rule: #functionCallExpression.	self assert: call identifier equals: 'speak'.	self assert: call arguments isEmpty! !!JbParserTest methodsFor: 'tests-expressions'!testFunctionCallStatement	| stmt |	stmt := self		        parse: 'banana("monkey", 12, 3+2);'		        rule: #functionCallStatement.	self assert: stmt identifier equals: 'banana'.	self assert: stmt arguments size equals: 3.	stmt := self parse: 'monkey  ( )   ;' rule: #functionCallStatement.	self assert: stmt identifier equals: 'monkey'.	self assert: stmt arguments size equals: 0! !!JbParserTest methodsFor: 'tests-expressions'!testExpression	"Arithmetic expressions are tested elsewhere.  This test includes one such expression but otherwise focuses on other types of expressions."	| exp |	exp := self parse: '3+4' rule: #expression.	self assertNode: exp lhs isConstant: 3.	self assertNode: exp isOperator: $+.	self assertNode: exp rhs isConstant: 4.	exp := self		       parse: 'function (a,b,something,nothing) { }'		       rule: #expression.	self assert: exp parameters size equals: 4.	exp := self parse: 'x == 1' rule: #expression.	self assert: exp operator equals: '=='.	exp := self parse: 'true' rule: #expression.	self assert: exp value.	exp := self parse: 'false' rule: #expression.	self deny: exp value.	exp := self parse: 'foo(1,2,3)' rule: #expression.	self assert: exp identifier equals: 'foo'! !!JbParserTest methodsFor: 'tests-expressions'!testExpressionList	| vals |	vals := self parse: '1,23,monkey,18+2*5' rule: #expressionList.	self assert: vals first value equals: 1.	self assert: vals second value equals: 23.	self assert: vals third identifier equals: 'monkey'.	self assert: vals fourth operator equals: $+.! !!JbParserTest methodsFor: 'tests-expressions'!testComparisonExpression	| exp |	exp := self parse: 'falafel==1' rule: #comparisonExpression.	self assert: exp lhs identifier equals: #falafel.	self assert: exp operator equals: '=='.	exp := self parse: 'falafel<1' rule: #comparisonExpression.	self assert: exp lhs identifier equals: #falafel.	self assert: exp operator equals: '<'.	exp := self parse: 'falafel<=1' rule: #comparisonExpression.	self assert: exp lhs identifier equals: #falafel.	self assert: exp operator equals: '<='.	exp := self parse: 'falafel>1' rule: #comparisonExpression.	self assert: exp lhs identifier equals: #falafel.	self assert: exp operator equals: '>'.	exp := self parse: 'falafel>=1' rule: #comparisonExpression.	self assert: exp lhs identifier equals: #falafel.	self assert: exp operator equals: '>='.	exp := self parse: 'falafel!!=1' rule: #comparisonExpression.	self assert: exp lhs identifier equals: #falafel.	self assert: exp operator equals: '!!='.! !!JbParserTest methodsFor: 'tests-expressions'!testAnonymousFunctionExpression	| f |	f := self parse: 'function (x,y,z) { }' rule: #anonymousFunctionExpression.	self assert: f body isEmpty.	self assert: f parameters size equals: 3.	f := self parse: 'function (a,b,something,nothing) { }' rule: #anonymousFunctionExpression.	self assert: f body isEmpty.	self assert: f parameters size equals: 4.	self fail: 'function (x+1) { }' rule: #anonymousFunctionExpression.! !!JbParserTest methodsFor: 'tests-expressions'!testIdentifierExpressionList	self assert: (self parse: 'apple,banana,monkey' rule: #identifierExpressionList) size equals: 3.	self assert: (self parse: '' rule: #identifierExpressionList) size equals: 0! !!JbParserTest methodsFor: 'tests-statements' stamp: 'NikkiU 11/25/2023 14:38'!testIfElseStatement	| input |	input := self parse: 'if (x==1) {} else {}' rule: #ifElseStatement.	self assert: input condition lhs identifier equals: #x.	self assert: input thenStatements size equals: 0.	self assert: input elseStatements size equals: 0.	self assert: input thenStatements equals: #(  ). "empty array"	input := self		         parse:		         'if (x == 1) {x = x + 1;} else {x = x + 2; y = y - 5;}'		         rule: #ifElseStatement.	self assert: input condition lhs identifier equals: #x.	self assertNode: input condition rhs isConstant: 1.	self assert: input thenStatements size equals: 1.	self assert: input elseStatements size equals: 2.	input := self		         parse: 'if (x == 1) {x = x + 1; y = 0;} else {x = x + 2;}'		         rule: #ifElseStatement.	self assert: input condition lhs identifier equals: #x.	self assertNode: input condition rhs isConstant: 1.	self assert: input thenStatements size equals: 2.	self assert: input elseStatements size equals: 1.	"Fail to parse tests"	self fail: 'if x == 1 { } else {}' rule: #ifElseStatement! !!JbParserTest methodsFor: 'tests-statements'!testStatement	| stmt |	stmt := self parse: 'var monkey = -1231 + x;' rule: #statement.	self assert: stmt identifier equals: 'monkey'.	stmt := self parse: 'zebra = 3 *x + 1;' rule: #statement.	self assert: stmt identifier equals: 'zebra'.	stmt := self parse: 'return x*y+1;' rule: #statement.	self assert: stmt expression lhs lhs identifier equals: 'x'! !!JbParserTest methodsFor: 'tests-statements'!testVariableDeclarationStatement	| stmt |	stmt := self parse: 'var x = 22;' rule: #variableDeclarationStatement.	self assert: stmt identifier equals: 'x'.	stmt := self parse: 'var monkey = 37*x;' rule: #variableDeclarationStatement.	self assert: stmt identifier equals: 'monkey'! !!JbParserTest methodsFor: 'tests-statements' stamp: 'NikkiU 12/1/2023 13:22'!testPrintStatement	| input |	input := self parse: 'print 5*monkey;' rule: #printStatement.	"expression produces JbMultiplcationNode"	self assert: input expression lhs value equals: 5.	self assert: input expression rhs identifier equals: 'monkey'.	"Fail to parse tests"	self fail: 'print if (x == 1) "hello";' rule: #printStatement! !!JbParserTest methodsFor: 'tests-statements' stamp: 'NikkiU 11/25/2023 11:45'!testInputStatement	| input |	input := self parse: 'inputnum a;' rule: #inputStatement.	self assert: input identifier equals: #a.	"Fail to parse tests"	self fail: 'inputnum 45;' rule: #inputStatement.	self fail: 'inputnum "hello";' rule: #inputStatement! !!JbParserTest methodsFor: 'tests-statements'!testReturnStatement	| func |	func := self parse: 'return 37;' rule: #returnStatement.	self assert: func expression value equals: 37! !!JbParserTest methodsFor: 'tests-statements' stamp: 'NikkiU 11/24/2023 14:02'!testWhileStatement	| input |	input := self parse: 'while (x < 5) {}' rule: #whileStatement.	self assert: input condition lhs identifier equals: #x.	self assert: input doStatements size equals: 0.	self assert: input doStatements equals: #(  ). "empty array"	input := self		         parse: 'while (x < 5) {x = x + 1;}'		         rule: #whileStatement.	self assert: input condition lhs identifier equals: #x.	self assertNode: input condition rhs isConstant: 5.	self assert: input doStatements size equals: 1.	"Fail to parse tests"	self fail: 'while x == 1 { }' rule: #whileStatement.	self fail: 'while (x == 1) x = x + 1;' rule: #whileStatement.	self fail: 'print while (x == 1) "hello";' rule: #whileStatement! !!JbParserTest methodsFor: 'tests-statements'!testStatementBlock 	| blk |	blk := self parse: '{ x = 1; var y = 23 * x; }' rule: #statementBlock.	self assert: blk size equals: 2.	self assert: blk first identifier equals: 'x'.	self assert: blk second identifier equals: 'y'! !!JbParserTest methodsFor: 'tests-statements'!testAnonymousFunctionDefinitionWithAssignment	| func |	func := self		        parse: 'function () {x = 22;}'		        rule: #anonymousFunctionExpression.	self assert: func body notEmpty.	self assert: func body first identifier equals: 'x'.	func := self		        parse: 'function(    ) {x = 22;}'		        rule: #anonymousFunctionExpression.	self assert: func body notEmpty.	self assert: func body first identifier equals: 'x'! !!JbParserTest methodsFor: 'tests-statements'!testAssignmentStatement	| exp |	exp := self parse: 'x = 33;' rule: #assignmentStatement.	self assert: exp identifier equals: 'x'.	self assert: exp expression value equals: 33! !!JbParserTest methodsFor: 'tests-statements' stamp: 'NikkiU 11/25/2023 14:38'!testIfStatement	| input |	input := self parse: 'if (x == 1) {}' rule: #ifStatement.	self assert: input condition lhs identifier equals: #x.	self assert: input thenStatements size equals: 0.	self assert: input thenStatements equals: #(  ). "empty array"	input := self		         parse: 'if (x == 1) {x = x + 1; y = y - 5;}'		         rule: #ifStatement.	self assert: input condition lhs identifier equals: #x.	self assertNode: input condition rhs isConstant: 1.	self assert: input thenStatements size equals: 2.	input := self parse: 'if(x==1){x=x+1;}' rule: #ifStatement.	self assert: input condition lhs identifier equals: #x.	self assert: input thenStatements size equals: 1.	"Fail to parse tests"	self fail: 'if x == 1 { }' rule: #ifStatement.	self fail: 'if (x == 1) x = x + 1;' rule: #ifStatement.	self fail: 'print if (x == 1) "hello";' rule: #ifStatement! !